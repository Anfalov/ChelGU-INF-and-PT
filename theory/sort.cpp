#include<iostream>
#include<vector>
#include<algorithm>
#include<functional>

using namespace std;

// Функциональный объект - объект, который можно вызвать
// как функцию, т.е. у него определён оператор вызова ()

struct myinc {
	int operator()(int& a)
	{
		a++;
		return a;
	}
};

bool comp(int a, int b) // Функция сравнения должна принимать два параметра и
{ // возвращать true, если первый должен стоять в массиве до второго
// (т.е. функция реализует операцию "меньше" так, будто бы элементы сравниваются
// друг с другом по их положению в отсортированном массиве)
	if (a > b)
		return true;
	else
		return false;
	// return a > b;
}

bool comp_matr(const vector<int>& a, const vector<int>& b)
{
	return a[0] < b[0];
}

int main()
{
	int a[10] = { 5, 3, 7, 9, 6, 88, 12, 1, 8, 5 };
	sort(a, a + 10); // Для сортировки обычных массивов в функцию передаётся
	// укзаатель на начало массива (имя массива) и указатель на конец
	// (имя массива + число испольуемых элементов нём)
	for (int i = 0; i < 10; i++)
		cout << a[i] << " ";
	cout << endl;

	int n;
	cin >> n;
	vector<int> v(n);
	for (int i = 0; i < n; i++)
		cin >> v[i];

	sort(v.begin(), v.end()); // В случае стандартных контейнеров (vector, deque,
	// string) в сорт передаются итераторы на начало и конец контейнера
	for (auto e : v)
		cout << e << " ";
	cout << endl;

	// Сортировка от большего к меньшему
	sort(v.rbegin(), v.rend()); // С помощью реверсивных указателей
	// Реверсивные указатели - позволяют проходить по контейнеру справа налево
	// rbegin - итератор на последний элемент контейнера
	// rend - итератор на элемент перед первым

	sort(v.begin(), v.end(), comp); // С помощью собственной функции сравнения
	// Третьим параметром передаётся укзатель на функцию сравнения (имя функции
	// без скобочек и параметров, описание этой функции смотрите выше)
	
	sort(v.begin(), v.end(), greater<int>()); // С помощью функционального объекта
	// из библиотеки functional
	// После имени объекта пишется тип элементов контейнера и круглые скобки,
	// т.к. вызывается конструктор для этого объекта

	for (auto e : v)
		cout << e << " ";
	cout << endl;

	/* Стабильная сортировка гарантирует, что элементы с одинаковыми ключами
	останутся в том же порядке друг относительно друга, в котором они были
	до этой сортировки:
	Аляпов 3
	Блохин 4
	Кутузов 3
	Юлаев 2
	Яковлев 5

	Яковлев 5
	Блохин 4
	Аляпов 3
	Кутузов 3
	Юлаев 2 */

	// Хотим отсортировать строки матрицы размера n x m по первым элементам строк
	int m;
	cin >> n >> m;
	vector<vector<int>> matr(n, vector<int>(m));
	for (int i = 0; i < n; i++)
		for (int j = 0; j < m; j++)
			cin >> matr[i][j];

	stable_sort(matr.begin(), matr.end(), comp_matr); // Гарантирует что элементы
	// (строки матрицы) с одинаковым ключом (первым элементом матрицы)
	// останутся в том же порядке друг относительно друга

	//sort(matr.begin(), matr.end(), comp_matr); // Сортирует, но не гарантирует,
	// что строки с одинаковым первым элементом не переместятся
	// друг относительно друга

	for (auto& w : matr)
	{
		for (auto e : w)
			cout << e << " ";
		cout << endl;
	}
	

	// Функциональные объекты:
	int q = 1;
	myinc mi;
	mi(q);
	cout << q << endl;
}
