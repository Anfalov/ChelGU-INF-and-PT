#include <iostream>
#include <set>
#include <unordered_set>

using namespace std;

int main()
{
	unordered_set<int> u_st{ 1, 2, 3, 4 }; // Все
	// операции за O(1). Значения расположены в
	// неизвестном порядке
	set<int> st; // Все операции за O(lon(n)).
	// Значения отсортированы

	st.insert(1); // Вставка элемента в множество
	st.insert(3); // Если вставить в множество
	st.insert(3); // элемент, который там уже есть,
	st.insert(2); // то он не будет вставлен
	st.insert(4);
	
	// Проход по множетсву:
	for (auto e : st)
		cout << e << " ";
	cout << endl;

	// Ссылка - константная, т.е. элементы множества
	// неизменяемы
	for (auto &e : st)
		cout << e << " ";
	cout << endl;

	// Проход с помощью итератора
	for (auto it = st.begin(); it != st.end(); it++)
		cout << *it << " ";
	cout << endl;
	
	// Есть ли элемент во множестве:
	cout << st.count(3) << " " << st.count(5) << endl;
	
	// Найти элемент множества:
	auto find_it = st.find(3); // Возвращает итератор
	// показывающий на искомый элемент или на st.end(),
	// если такого элемента в сете нет

	st.erase(2); // Можно удалять по значению, тогда
	// для обычного сета время работы будет O(log(n))
	st.erase(find_it); // Можно удалять по указателю,
	// в этом случае удаление пройдёт за O(1)
	// Например, таким образом за O(1) можно удалять
	// первый элемент множества st.begin()
	// erase по значению возвращает 1, если удало удалить
	// элемент и 0, если такого элемента не было
	// erase по итератору возвращает iterator на
	// следующий элемент

	for (auto e : st)
		cout << e << " ";
	cout << endl;
	st.insert(6);
	st.insert(3);
	for (auto it = st.begin(); it != st.end();)
		if (*it % 2 == 0)
			it = st.erase(it);
		else
			it++;
	for (auto e : st)
		cout << e << " ";
	cout << endl;
	cout << st.size() << endl;
	st.clear(); // Очистить сет

	// st.swap(st2); // можно поменять местами с другим
	// сетом за O(1)
  
  // Время работы unordred_set - не чистая константа,
  // так как из-за совпадения хэшей у разных значений
  // поиск и остальные действия могут выполняться дольше
  // (вплоть до O(n)), а также может произойти rehash,
  // который выполняется от O(n) в среднем до O(n^2)
  // в худшем случае. 
}
